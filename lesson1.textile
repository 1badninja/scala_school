Lesson 1

Today we'll cover:
* values
* expressions
* functions
* classes
* methods
* basic inheritance

As a note: all of our examples will be shown with the interactive
interpreter rather than compiled. The interpreter makes it easy to
explore problems.

h2. Start the Interpreter

<pre>
$ scala

Welcome to Scala version 2.8.0.final (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_20).
Type in expressions to have them evaluated.
Type :help for more information.

scala>
</pre>


h2. Expressions

<pre>
scala> 1 + 1
res0: Int = 2
</pre>

res0 is an automatically created value name given by the interpreter
to the result of your expression. It has the type Int and contains the
Integer 2.

Everything in Scala is an expression.

h2. Values

You can give the result of an expression a name

<pre>
scala> val two = 1 + 1
two: Int = 2
</pre>

h3. Functions

You can create functions with def.

<pre>
scala> def addOne(m: Int): Int = m + 1
addOne: (m: Int)Int
</pre>

In Scala, you need to specify the type signature for function
parameters. The interpreter happily repeats the type signature back to
you.

<pre>
scala> val three = addOne(2)
three: Int = 3
</pre>

h3. Classes

<pre>
scala> class Calculator {
     |   def add(m: Int, n: Int): Int = m + n
     | }
defined class Calculator

scala> val calc = new Calculator
calc: Calculator = Calculator@e75a11

scala> calc.add(1, 2)
res1: Int = 3
</pre>

Constructors aren't special methods, they are the code outside of
method definitions in your class.

<pre>
class BasicCalculator(brand: String) {
  val color = if (brand == "TI") {
    "blue"
  else if (brand == "HP") {
    "black"
  }
}
</pre>

h3. Inheritance

<pre>
class ScientificCalculator(brand: String) extends BasicCalculator(brand) {
  def log(m: Double, base: Double) = math.log(x) / math.log(base)
}
</pre>

h3. Overloading methods

<pre>
class EvenMoreScientificCalculator(brand: String) extends BasicCalculator(brand) {
  def foo(m: Int) = foo(m, math.exp(1))
}
</pre>
