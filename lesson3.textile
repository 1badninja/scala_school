Lesson 3

Today we'll cover:
* Lists
* Maps
* functional combinators
** map
** foreach
** filter
** zip
** foldRight and foldLeft


h2. Preliminaries

Reminders from Lessons 1 & 2: A simpler time.

h4. Functions

The humble function

<pre>
def timesTwo(i: Int): Int = i * 2
</pre>

An anonymous function

<pre>
(i: Int) => i * 2
</pre>

You can assign an anonymous function to a value, thus giving it a name.

<pre>
val timesTwo = (i: Int) =&gt; i * 2
</pre>

If your function is made up of many expressions, you can use {} to give yourself some breathing room.

<pre>
def timesTwo(i: Int): Int = {
  println("hello world")
  i * 2
}
</pre>

This is also true of an anonymous function

<pre>
scala&gt; { i: Int =&gt;
  println("hello world")
  i * 2
}
res0: (Int) =&gt; Int = &gt;function1&lt;
</pre>

You will see this syntax often used when passing an anonymous function as an argument.


h4. Partial application

You can partially apply a function with an underscore, which gives you another function.

<pre>
scala> timesTwo _
res0: (Int) =&gt; Int = &lt;function1&gt;
</pre>

h4. Curried functions

Sometimes it makes sense to let people apply some arguments to your
function now and others later.


This sometimes lead to crazy pieces of code like:

<pre>
multThenFilter { i: Int =&gt;
  i * 2
} { i: Int =&gt;
  i < 5
}
</pre>

I promise you get used to this over time.

h2. Basic Datastructures

h3. Lists

<pre>
val numbers = List(1, 2, 3, 4)
numbers: List[Int] = List(1, 2, 3, 4)
</pre>

Scala realized you were talking about a List of Ints and so parameterized it.

You can parameterize it manually if you want.

List[Int](1, 2, 3, 4)

You can also build lists with :: by appending elements onto the empty list: Nil.

<pre>
scala&gt; val numbers = 1 :: 2 :: 3 :: 4 :: Nil
numbers: List[Int] = List(1, 2, 3, 4)
</pre>

h3. Maps

It can hold basic datatypes.

<pre>
Map(1 -&gt; 2)
Map("foo" -&gt; "bar")
</pre>

Nested Maps:
<pre>
Map(1 -&gt; Map("foo" -&gt; "bar"))
</pre>

You can even hold functions in there:
<pre>
Map("timesTwo" -&gt; timesTwo _)
</pre>

h3. Tuple

Tuples are used for grouping together simple logical collections of
items without using a class.

<pre>
scala&gt; val hostPort = ("localhost", 80)
hostPort: (java.lang.String, Int) = (localhost, 80)
</pre>

Unlike case classes, they don't have named accessors, instead they
have accessors that are named by their position (1-based).

<pre>
scala&gt; hostPort._1
res0: java.lang.String = localhost

scala&gt; hostPort._2
res1: Int = 80
</pre>

Tuples fit with pattern matching nicely.

hostPort match {
  case ("localhost", port) => ...
  case (host, port) => ...
}

h2. Functional Combinators

This fancy name is giving to a standard set of functions that can be
applied to Lists and Maps.

They are called combinators because they are meant to be combined. the
output of one function is often suitable as the input for another.

h4. map

Evaluates a function over each element in the list, returning a list
with the same number of elements.

<pre>
scala&gt; numbers.map((i: Int) =&gt; i * 2)
res0: List[Int] = List(2, 4, 6, 8)
</pre>

or pass in a partially evaluated function

<pre>

scala&gt; def timesTwo(i: Int): Int = i * 2
timesTwo: (i: Int)Int

scala&gt; numbers.map(timesTwo _)
res0: List[Int] = List(2, 4, 6, 8)
</pre>

h4. foreach

foreach is like map but returns nothing. foreach is intended for side-effects only.

h4. filter

removes any elements where the function you pass in evaluates to
false. Functions that return a Boolean are often called predicate
functions.

<pre>
scala&gt; numbers.filter((i: Int) =&gt; i % 2 == 0)
res0: List[Int] = List(2, 4)
</pre>

<pre>
scala&gt; def isEven(i: Int): Boolean = i % 2 == 0
isEven: (i: Int)Boolean

scala&gt; numbers.filter(isEven _)
res2: List[Int] = List(2, 4)
</pre>

h4. zip

zip aggregates the contents of two lists into a single list of pairs.

<pre>
scala&gt; List(1, 2, 3).zip(List("a", "b", "c"))
res0: List[(Int, java.lang.String)] = List((1,a), (2,b), (3,c))
</pre>

h4. partition

partition splits a list based on where it falls with respect to a
predicate function.

<pre>
scala&gt; List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).partition((i: Int) =&gt; i &gt; 5)
res0: (List[Int], List[Int]) = (List(6, 7, 8, 9, 10),List(1, 2, 3, 4, 5))
</pre>

h4. find

find returns the first element of a collection that matches a predicate function.

<pre>
scala&gt; numbers.find((i: Int) =&gt; i &gt; 5)
res0: Option[Int] = Some(6)
</pre>

h4. drop & dropWhile

Drops the first i elements

<pre>
scala&gt; numbers.drop(5)
res0: List[Int] = List(6, 7, 8, 9, 10)
</pre>

dropWhile removes elements that don't match a predicate function. Here
we can re-implement drop.

<pre>
scala&gt; numbers.dropWhile((i: Int) =&gt; i &lt; 6)
res0: List[Int] = List(6, 7, 8, 9, 10)
</pre>

h4. foldLeft

<pre>
scala&gt; numbers.foldLeft(0)((m: Int, n: Int) =&gt; m + n)
res0: Int = 55
</pre>

0 is the starting value (Remember that numbers is a List[Int]), and m
acts as an accumulator.

Seen visually:
<pre>
scala&gt; numbers.foldLeft(0) { (m: Int, n: Int) =&gt;
  println("m: " + m + " n: " + n)
  m + n
}

m: 0 n: 1
m: 1 n: 2
m: 3 n: 3
m: 6 n: 4
m: 10 n: 5
m: 15 n: 6
m: 21 n: 7
m: 28 n: 8
m: 36 n: 9
m: 45 n: 10
res0: Int = 55
</pre>

h5. foldRight

Is the same as foldLeft except it runs in the opposite direction.

<pre>
scala&gt; numbers.foldRight(0) { (m: Int, n: Int) =&gt; println("m: " + m + " n: " + n); m + n }
m: 10 n: 0
m: 9 n: 10
m: 8 n: 19
m: 7 n: 27
m: 6 n: 34
m: 5 n: 40
m: 4 n: 45
m: 3 n: 49
m: 2 n: 52
m: 1 n: 54
res0: Int = 55
</pre>


h4. Generalized functional combinators

Now we've learned a grab-bag of functions for working with
collections.

What we'd like is to be able to write our own functional combinators.

Interestingly, every functional combinator shown above can be written
on top of fold. Let's see some examples.

<pre>
def map(numbers: List[Int], fn: Int => Int): List[Int] = {
  numbers.foldRight(List[Int]()) { (x: Int, xs: List[Int]) =>
    fn(x) :: xs
  }
}

scala&gt; map(numbers, timesTwo _)
res0: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
</pre>

Why List[Int]()? Scala wasn't smart enough to realize that you wanted an empty list of Ints to accumulate into.
